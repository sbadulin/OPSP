// ConsoleApplication2.cpp: определяет точку входа для консольного приложения.
//

// #include "stdafx.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <clocale> // для использования setlocale


// ---Задание 1---

	/* Проверяем, является ли заданный символ разделителем */

void testWord(char line[]);
char delimeters[] = { ' ', '\0', '\n' }; //Список символов - разделителей задаем массивом delimeters
char word[128]; // Хранение символов в слове

int isDelimeter(char ch) {
	/* Проверяем, является ли заданный символ разделителем
	Если да, возвращаем 1, если нет - 0  */

	int i; //Объявляем переменную счетчика
	for (i = 0; i < sizeof(delimeters); i++) { // Просматриваем все элементы массива
		if (ch == delimeters[i]) { // Если заданный символ совпадаем с элементом массива
			return 1; // Возвращаем 1
		} //if
	} //for
	return 0; // Если не вернули 1, то возвращаем 0
}


// ---Задание 2---

	/* Ввод строки с консоли в массив */

int fromConsole(char line[]) {
	// Заполняем массив вводимыми в консоли символами и выводим длину введенной строки

	char ch; // Инициализируем переменную для хранения введенного символа
	int i = 0; // Инициализируем счетчик
	scanf("%c", &ch); // Считываем первый введенный символ
	while ((ch != '\n') && (i < 127)) {
		// Заполняем массив введенными символами, пока не появится перенос строки или массив не переполнится

		line[i] = ch; // Присваиваем текущему элементу массива введенный символ
		i++; // Инкрементируем счетчик
		scanf("%c", &ch); // Считывам следующий символ
	}
	line[i] = '\0'; // Присваиваем последнему элементу массива символ окончания строки
	// printf("%s\n", line); // Выводим полученный массив как строку (для проверки)
	return i; // Возвращаем длину введенной строки (совпадает с счетчиком)
}

// ---Задание 3---

	/* Подсчитывает число слов в строке символов */

int countWords(char arr[]) {

	int i = 0; // Счетчик для прохода массива
	int q = 0; // Исходное состояние автомата
	int ret = 0; //Число слов в строке
	int wc = 0; // Счетчик для позиции в массиве word

	// Описываем состояния конечного автомата: q0 - начальное, q1 - найден символ разделитель, q2 - найден значимый символ

	while (arr[i] != '\0') { // Проходим массив, пока не встретим символ конца строки (последний элемент)
		if (q == 0) { // Если находимся в исходном состоянии автомата
			if (isDelimeter(arr[i])) { // Если символ является разделителем
				q = 1; // Переходим в состояние 1
				i++; // Инкр. счетчик
				continue; // Переходим к следующему шагу цикла
			}
			word[wc] = arr[i]; // добавляем к слову текущий символ из массива
			wc++; // Увеличиваем счетчик

			q = 2; // Переходим в сост. 2
			i++; // Инкр. счетчик
			continue; // Переходим к следующему шагу цикла
		}
		if (q == 1) { //Если находимся в состоянии автомата 1
			if (isDelimeter(arr[i])) { // Если проверяемый символ - разделитель
				i++; // Инкр. счетчик
				continue; // Переходим к следующему шагу цикла
			}
			word[wc] = arr[i]; // добавляем к слову текущий символ из массива
			wc++; // Увеличиваем счетчик
			q = 2; // Переходим в сост. 2
			i++; // Инкр. счетчик
			continue; // Переходим к следующему шагу цикла
		}
		if (q == 2) { //Если находимся в состоянии автомата 1
			if (isDelimeter(arr[i])) { // Если проверяемый символ - разделитель

									   // Прекращаем добавлять символы в слово и выводим его
				word[wc] = '\0'; // добавляем символ конца строки
				//printf("%s\n", word); // выводим слово
				testWord(word);
				wc = 0; // Обнуляем счетчик обхода слова

				ret++; // Увеличиваем счетчик слов
				q = 1; // Переходим в состояние 1
				i++; // Инкр. счетчик
				continue; // Переходим к следующему шагу цикла
			}
			word[wc] = arr[i]; // добавляем к слову текущий символ из массива
			wc++; // Увеличиваем счетчик
			i++; // Инкр. счетчик
			continue; // Переходим к следующему шагу цикла
		}
	}
	if (q == 2) { // Если по окончанию цикла находимся в состоянии 2
		word[wc] = '\0'; // добавляем символ конца строки
		// printf("%s\n", word); // выводим слово
		testWord(word); // При нахождении заданного слова закрываем консоль
		wc = 0; // Обнуляем счетчик обхода слова
		ret++; // Увеличиваем счетчик слов
	}

	return ret; // Возвращаем значение счетчика слов
}

// ---Бонус---

	// При нахождении слова shutdown зыкрываем консоль

void testWord(char line[]) {
	if (strcmp(line, "shutdown") == 0) { //сравнивем поданую и заданную
		exit(0); // Выход с кодом 0
	}
	return;
}


// ---Задание 4---

	/* Чтение заданной строки из файла */

int readFromFile(FILE* file, char line[], int number) {
	/* Возвращает количество символов в строке number файла file, нумеруется от нуля.
	Складываем строку в символьный массив line */
	int i = 0;

	// считываем символы в массив

	if (file != NULL) { // если файл открылся
		char ret; // переменная для считываемого символа
		fscanf(file, "%c", &ret); // берем первый символ из файла

		// сначала убираем из потока ввода (файла) лишние строки
		while (!feof(file) && number > 0) { // если нужная строка еще не найдена, а конец файла не достигнут
			if (ret == '\n') { // если дошли до конца строки
				number--; // приближаемся к нужной (нулевой) строке
			}
			fscanf(file, "%c", &ret); // берем следующий символ
		}
		// если число строк осталось больше нуля, значит в файле их нет
		if (number > 0) {
			line[0] = '\0';
			return 0;
		}
		// начинаем записывать искомую строку в массив, пока не встретим конец строки
		while (ret != '\n') {
			line[i] = ret;
			i++;
			fscanf(file, "%c", &ret);
			if (feof(file)) {
				break;
			}
		}
		// длина массива равна числу проходов i через ^^^ цикл
		return i; // возвращаем искомое значение
	}
	else {
		printf("File troubles\n");
		return 0;
	}
}

// ---Задание 5---

	/* Возвращаем int - число слов в файле. */

int countFileWords(FILE* file) {
	int numberOfWords = 0;
	char line[128]; // буфер для считанной строки
	if (file != NULL) { // если файл открылся

	while (!feof(file)) {
			// очищаем буфер для цикла
			for (int i = 0; i < 128; i++) {
				line[i] = '\0';
			}
			readFromFile(file, line, 0); // читаем очередную строку
			numberOfWords += countWords(line); // увеличиваем счетчик слов
			printf("Текущая строка: %s\n", line);
		}

	}
	return numberOfWords;
}


// ---Задание 6---

	/* Выводим в консоль содержимое файла */

int toConsole(FILE* file) {
	int lineNum = 0;
	char line[128]; // буфер для считанной строки
  while (!feof(file)) {
		// очищаем буфер для цикла
		for (int i = 0; i < 128; i++) {
			line[i] = '\0';
		}
	  readFromFile(file, line, 0); // читаем поток файла построчно в буфер
		printf("%s\n", line); // выводим буфер в консоль

	}
}


int main(int argc, char* argv[])
{
	setlocale(LC_CTYPE, "rus"); // функция настройки локали

	char line[128]; // инициализируем буфер для считываемых из файла символов

	// Задание 1 - Проверяем, является ли заданный символ разделителем

			// char ch = 'y'; // Задаем проверяемый символ
			// printf("%i\n", isDelimeter(ch)); // Выводим в консоль результат выполнения функции isDelimeter

	// Задание 2 - Ввод строки с консоли в массив

			// printf("%i\n", fromConsole(line)); // Выводим длину введенной строки

	// Задание 3 - Число слов в строке символов

		//  fromConsole(line); // заполняем массив
		//  printf("\nЧисло слов в строке: %i\n", countWords(line)); // Выводим число слов

	FILE* sFile; // присваиваем логическое имя файлу
	sFile = fopen("temp.txt", "r"); // открываем файл с данными в режиме чтения

	// Задание 4

		// printf("\nДлина строки: %i\n", readFromFile(sFile, line, 1));

	// Задание 5 - Считаем слова в файле

		printf("\nЧисло слов в файле: %i\n", countFileWords(sFile));

	// Задание 6 - Выводим в консоль содержимое файла

		// toConsole(sFile);

  printf("\n");
	system("pause"); // Ждем ввода символа с клавиатуры

	return 0;
}
